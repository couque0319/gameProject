<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í—ˆì ‘ íƒ‘ë·° ë¹„í–‰ìŠˆíŒ…</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #222;
        }

        canvas {
            border: 2px solid #fff;
            background-color: #000;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
</head>

<body>

    <script>
        const config = {
            type: Phaser.AUTO,
            width: 480, // ê²Œì„ í™”ë©´ ë„ˆë¹„ (ì˜ˆ: ëª¨ë°”ì¼ í™”ë©´)
            height: 640, // ê²Œì„ í™”ë©´ ë†’ì´
            parent: 'game-container', // HTMLì— id='game-container'ì¸ divê°€ ì—†ìœ¼ë©´ bodyì— ë¶™ìŠµë‹ˆë‹¤.
            physics: {
                default: 'arcade',
                arcade: {
                    debug: false // ì¶©ëŒ ë°•ìŠ¤ë¥¼ ë³´ë ¤ë©´ true
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const game = new Phaser.Game(config);

        const BULLET_SKINS = ['bulletB1', 'bulletR1', 'bulletG1', 'bulletW1']; //ver3
        const __FIRERATE_TABLE = [200, 125, 83, 67]; //ver3
        const __DAMAGE_TABLE = [20, 25, 32, 40]; //ver3
        const __MISSILE_DAMAGE_TABLE = [80, 100, 125, 150]; //ver3
        const missile = {   //ver3
            cooldownMs: 5000,     // ì¿¨ 5ì´ˆ
            lastFiredAt: -Infinity,
            preHoldMs: 1000,       // í…ŒìŠ¤íŠ¸ìš©ìœ¼ë¡œ 2ì´ˆë¡œ ë§‰ì•„ë†“ìŒ ì´í›„ 330ìœ¼ë¡œ ë³€ê²½
            postHoldMs: 330,      // ë°œì‚¬ ëŒ€ê¸°
            speed: 400,
            maxFlightMs: 1300,
            explosionRadius: 160,
            explosionLifeMs: 240, // í­ë°œ ì‹œê°íš¨ê³¼ ìœ ì§€ì‹œê°„
            explosionDamage: 80,
            staggerMs: 70,     // êµì°¨ ì—°ì‚¬ ì‹œê°„ì°¨ (ms) â€” 60~90ms ê¶Œì¥
            nextSide: 1
        };


        let player;
        let bullets;
        let enemies;
        let lastFired = 0; // ì´ì•Œ ë°œì‚¬ ë”œë ˆì´ë¥¼ ìœ„í•œ ì‹œê°„
        let score = 0;
        let scoreText;
        let gameOver = false;

        //--------ìˆ˜ì •1-----------------------------------------------


        let battleOn = true;      // ì „íˆ¬ ìƒíƒœ í”Œë˜ê·¸ (ON/OFF)
        let enemySpawnEvent;
        let carrierEventOn = false;
        let docking = {
            active: false,
            carrier: null,
            guide: null,
            guideLeftX: 200,
            guideRightX: 280,
            tolerance: 18,
            descentPxPerSec: 60,
            targetY: 0,
            lockOffsetPx: 0   // ğŸ‘ˆ ì¶”ê°€: â€˜ì•„ë˜ì—ì„œ ì–¼ë§ˆë‚˜ ìœ„â€™ë¥¼ ë½ íŒì •ì„ ìœ¼ë¡œ ì“¸ì§€
        };
        let sway = {
            active: false,
            locked: false,        // ì ‘ì´‰ í›„ ê³ ì • ìƒíƒœ
            playerBaseX: null,    // ì…ë ¥ìœ¼ë¡œ ì •í•œ ê¸°ì¤€ x
            playerPhase: 0,       // í”Œë ˆì´ì–´ í”ë“¤ë¦¼ ìœ„ìƒ
            playerAmp: 14,        // í”Œë ˆì´ì–´ í”ë“¤ë¦¼ ì§„í­(px)
            playerHz: 0.9,        // í”Œë ˆì´ì–´ í”ë“¤ë¦¼ ì£¼íŒŒìˆ˜(Hz)
            carrierAmp: 26,       // í•­ëª¨ í”ë“¤ë¦¼ ì§„í­(px)
            carrierTween: null    // í•­ëª¨ ì¢Œìš° ë“œë¦¬í”„íŠ¸ íŠ¸ìœˆ í•¸ë“¤
        };
        let __engineShutdownPlayed = false;
        let __approachBannerShown = false; //ver2
        let weapon = {           //ver3
            fireRateMs: 333,
            bulletSpeed: 400,
            bulletKey: 'bullet_blue',
            pattern: 1,
            spreadDeg: 10,
            damage: 1,
            hitboxScaleX: 1.0,   // ğŸ”¸ Xì¶• í”¼ê²© íŒì • ë°°ìˆ˜ (1.0=ê¸°ë³¸, 1.5/2.5 ë“±)
        };
        let gold = 999;         //ver2
        let goldHUDText = null; //ver2
        let shop = {             //ver2
            active: false,
            depthBase: 220,

            // ë°°ì¹˜/ì»¨í…Œì´ë„ˆ /ver2
            container: null,
            bg: null,
            keys: null,
            slots: [],

            // êµ¬ë§¤ 1íšŒì„± / ë‹¨ê³„í˜• //ver2
            purchasedOnce: { q: false, w: false, e: false, r: false },
            tier: { a: 0, s: 0, d: 0 },

            // ì „ì—­ ì§„í–‰ë°” (íŒ¨ë„ í•˜ë‹¨ 1ê°œ) //ver2
            holdingKey: null,
            holdingStart: null,
            holdMsRequired: 2000,
            holdBarBg: null,
            holdBar: null,
            holdLabel: null,
            holdHint: null,
        };
        let launch = {  //ver2
            active: false,
            lines: [],
            nextRemoveAt: 0,
            removeInterval: 300, // 0.3ì´ˆ ê°„ê²© ì œê±°
            bigTitle: null       // "Engine ignition Start"
        };
        let __engineIgnitionPlayed = false; //ver2
        let missiles, explosions; // ver3
        let primaryHold = { active: false }; // ver3
        let missileHUDText; // ver3

        // ë‹¨ë°œ í•´ê¸ˆ(QWER) & 3ë‹¨ê³„ ì—…ê¸€(ASD) ìƒíƒœ          //ver2
        shop.purchasedOnce = { '1': false, '2': false, '3': false, '4': false };
        shop.tier = { a: 0, s: 0, d: 0 }; // 5=a(ì—°ì‚¬), 6=s(ë°ë¯¸ì§€), 7=d(ì²´ë ¥)

        weapon.bulletKey = 'bulletB1'; // ver3

        function spawnEnemy() {
            if (gameOver || !battleOn) return;

            let x = Phaser.Math.Between(50, config.width - 50);
            let enemy = enemies.create(x, -50, 'enemy')
                .setOrigin(0.5, 0.5)
                .setDisplaySize(30, 30)
                .setTint(0xff0000);

            enemy.setVelocityY(Phaser.Math.Between(50, 150));
            enemy.body.setSize(30, 30);
            enemy.body.collideWorldBounds = false;
            enemy.body.bounce.set(1);
        }

        function setBattle(on) { // ver3
            battleOn = on;
            if (enemySpawnEvent) enemySpawnEvent.paused = !on; // ìŠ¤í° íƒ€ì´ë¨¸ ì¼ì‹œì •ì§€/ì¬ê°œ

            // ğŸ”¹ ë¯¸ì‚¬ì¼ HUD í† ê¸€ (ì „íˆ¬ OFFë©´ HUD OFF)
            if (missileHUDText) {
                if (!on) {
                    missileHUDText.setAlpha(0).setText('');
                } else {
                    // ì „íˆ¬ ONì¼ ë•Œ í•´ê¸ˆ ì—¬ë¶€ ë”°ë¼ í‘œì‹œ
                    const unlocked = !!(shop?.purchasedOnce?.['3']);
                    missileHUDText.setAlpha(unlocked ? 1 : 0);
                }
            }
        }

        function showCarrierApproachBanner(scene) { //ver2
            const cx = config.width / 2;
            const cy = Math.round(config.height * 0.42);

            const t = scene.add.text(cx, cy, 'CARRIER APPROACH!', {
                fontSize: '32px',
                fontStyle: 'bold',
                color: '#fff7d6',
                stroke: '#0b1a2a',
                strokeThickness: 6,
                fontFamily: 'monospace'
            })
                .setOrigin(0.5)
                .setDepth(520)
                .setAlpha(0)
                .setScale(0.92);

            // ë“±ì¥ (ëŠë¦¬ê²Œ)
            scene.tweens.add({
                targets: t,
                alpha: { from: 0, to: 1 },
                y: '-=10',
                duration: 600, // â† 300 â†’ 600ìœ¼ë¡œ 2ë°°
                ease: 'Cubic.easeOut'
            });

            // íŒí•‘ (ëŠë¦¬ê²Œ)
            scene.tweens.add({
                targets: t,
                scale: { from: 0.92, to: 1.0 },
                yoyo: true,
                duration: 1300, // â† 650 â†’ 1300ìœ¼ë¡œ 2ë°°
                ease: 'Sine.easeInOut',
                repeat: 1
            });

            // ì‚¬ë¼ì§ (ëŠë¦¬ê²Œ)
            scene.time.delayedCall(2800, () => { // â† 1400 â†’ 2800
                scene.tweens.add({
                    targets: t,
                    alpha: 0,
                    y: '-=6',
                    duration: 520, // â† 260 â†’ 520
                    ease: 'Cubic.easeIn',
                    onComplete: () => t.destroy()
                });
            });
        }

        function startCarrierApproach(scene) { //ver2
            if (carrierEventOn) return;
            carrierEventOn = true;

            setBattle(false);

            // 1.5ì´ˆ í›„ "CARRIER APPROACH!" ì¶œë ¥ (ê¸°ì¡´ ê·¸ëŒ€ë¡œ)
            scene.time.delayedCall(1500, () => {
                if (!__approachBannerShown) {
                    __approachBannerShown = true;
                    showCarrierApproachBanner(scene);
                }
            });

            // ğŸ”¸ í•­ëª¨ ë“±ì¥ì€ 2ì´ˆ ë’¤ì— ì‹œì‘í•˜ë„ë¡ ë”œë ˆì´ ì¶”ê°€
            scene.time.delayedCall(2000, () => {
                const carrierTexture = scene.textures.get('carrier').getSourceImage();
                const carrierHeight = carrierTexture.height;

                const carrier = scene.add.image(config.width / 2, config.height + carrierHeight, 'carrier')
                    .setOrigin(0.5, 1)
                    .setScale(0.48)
                    .setDepth(20);

                // ê¸°ì¡´ íŠ¸ìœˆ ì‹œí€€ìŠ¤ ì „ì²´ â†“ ê·¸ëŒ€ë¡œ ìœ ì§€
                scene.tweens.add({
                    targets: carrier,
                    y: -80,
                    duration: 6100,
                    ease: 'Sine.easeInOut',
                    onComplete: () => {
                        const VISIBLE_RATIO = 2 / 5;
                        const srcH = scene.textures.get('carrier').getSourceImage().height;
                        carrier.setScale(1.0);
                        carrier.y = -srcH * 0.6;
                        carrier.alpha = 0;

                        const targetVisibleY = carrier.displayHeight * VISIBLE_RATIO;

                        scene.tweens.add({
                            targets: carrier,
                            y: targetVisibleY,
                            alpha: 1,
                            duration: 3000,
                            ease: 'Cubic.easeOut',
                            onComplete: () => {
                                startCarrierDocking(scene, carrier);
                            }
                        });

                        scene.tweens.add({
                            targets: carrier,
                            scaleX: 1.02,
                            scaleY: 1.02,
                            duration: 700,
                            yoyo: true,
                            repeat: 1,
                            ease: 'Sine.easeInOut'
                        });
                    }
                });
            });
        }


        function drawGuides(scene, aligned) {
            if (!docking.guide) {
                docking.guide = scene.add.graphics().setDepth(5); // ìœ ë„ì„ ì€ ê°€ì¥ ë’¤
            }
            const g = docking.guide;
            g.clear();

            const color = aligned ? 0x33e0ff : 0x3399ff;
            g.lineStyle(3, color, 1);

            // ----- ì—¬ê¸°ë¶€í„° 'ìƒë‹¨ ë°˜ë§Œ ìë¥´ê¸°' ë¡œì§ -----
            // carrierì˜ ì„¸ë¡œ ì¤‘ì•™ ì¢Œí‘œ (origin 0.5, 1 ì´ë¯€ë¡œ y - displayHeight/2)
            let topCropY = 0;
            if (docking.carrier) {
                const carrierMidY = docking.carrier.y - docking.carrier.displayHeight / 2;
                // í•­ëª¨ì˜ 'ì¤‘ì•™'ì´ í™”ë©´ ì¤‘ì•™ì„ ì§€ë‚˜ë©´ ìœ„ìª½ì„ ì˜ë¼ë‚´ê³  í•˜ë‹¨ë§Œ ë‚¨ê¹€
                if (carrierMidY >= config.height / 2) {
                    topCropY = config.height / 2; // í™”ë©´ ì¤‘ì•™ë¶€í„° ì•„ë˜ë§Œ ê·¸ë¦¼
                }
            }
            // -----------------------------------------

            // ì ì„ ì²˜ëŸ¼ ë³´ì´ê²Œ ì„¸ê·¸ë¨¼íŠ¸ë¡œ ë‘ ì¤„ ëª¨ë‘ ê·¸ë¦¼
            const seg = 12, gap = 8, bottom = config.height;

            // ì™¼ìª½ ë¼ì¸
            let y = topCropY;
            while (y < bottom) {
                g.strokeLineShape(new Phaser.Geom.Line(docking.guideLeftX, y, docking.guideLeftX, Math.min(y + seg, bottom)));
                y += seg + gap;
            }

            // ì˜¤ë¥¸ìª½ ë¼ì¸
            y = topCropY;
            while (y < bottom) {
                g.strokeLineShape(new Phaser.Geom.Line(docking.guideRightX, y, docking.guideRightX, Math.min(y + seg, bottom)));
                y += seg + gap;
            }
        }

        function startCarrierDocking(scene, carrier) {
            docking.active = true;
            docking.carrier = carrier;

            // ì¤‘ì•™ ê¸°ì¤€ ì¢Œìš°ë¡œ ë²Œë¦° ë‘ ì„  (ì›í•˜ë©´ ìˆ˜ì¹˜ ì¡°ì •)
            const center = config.width / 2;
            const halfGap = 24; // ë¼ì¸ ê°„ê²© ì ˆë°˜ (ì´ ê°„ê²© 80px)
            docking.guideLeftX = center - halfGap;
            docking.guideRightX = center + halfGap;

            docking.tolerance = 12;
            docking.descentPxPerSec = 40;
            docking.targetY = docking.carrier.displayHeight * 0.95;

            drawGuides(scene, false);

            sway.active = true; //í”ë“¤ë¦¼ ì‹œì‘
            sway.locked = false;
            if (sway.carrierTween) { sway.carrierTween.remove(); sway.carrierTween = null; }

            docking.lockOffsetPx = docking.carrier.displayHeight * 0.3;
            docking.ascentPxPerSec = 20;    // ì •ë ¬ ì•ˆ ëì„ ë•Œ ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” ì†ë„(íŠœë‹ ê°€ëŠ¥)
            docking.minY = carrier.y;       // ë„í‚¹ ì‹œì‘ ë‹¹ì‹œì˜ yë³´ë‹¤ ë” ìœ„ë¡œëŠ” ëª» ì˜¬ë¼ê°€ê²Œ ìƒí•œ
        }

        function lockToCenter(scene) {
            sway.locked = true;          // ì¡°ì‘ ë§‰ìŒ
            sway.active = true;          // (í”ë“¤ë¦¼ ì‹œìŠ¤í…œì€ ìœ ì§€)
            setBattle(false);            // ì „íˆ¬ëŠ” ê³„ì† OFF ìœ ì§€

            const cx = config.width / 2;

            // ìœ ë„ì„ /í•­ëª¨/í”Œë ˆì´ì–´ ëª¨ë‘ ì¤‘ì•™ ì •ë ¬
            // (í•­ëª¨ëŠ” ë¶€ë“œëŸ½ê²Œ, í”Œë ˆì´ì–´ëŠ” ì§§ê²Œ)
            if (sway.carrierTween) { sway.carrierTween.remove(); sway.carrierTween = null; }
            scene.tweens.add({
                targets: docking.carrier,
                x: cx,
                duration: 600,
                ease: 'Sine.easeInOut'
            });

            scene.tweens.add({
                targets: player,
                x: cx,
                duration: 300,
                ease: 'Sine.easeOut'
            });

            // í”Œë ˆì´ì–´ ì…ë ¥ ë¬´ì‹œ: ê¸°ì¤€ xë„ ì¤‘ì•™ìœ¼ë¡œ ê³ ì •
            sway.playerBaseX = cx;

            // (ì„ íƒ) ìœ ë„ì„ ë„ ì¤‘ì•™ì— ë§ì¶˜ë‹¤ë©´:
            docking.guideLeftX = cx - (docking.guideRightX - docking.guideLeftX) / 2;
            docking.guideRightX = cx + (docking.guideRightX - docking.guideLeftX) / 2;
        }

        function playEngineShutdown(scene, opts = {}) {
            const openDelayMs = opts.delayMs ?? 3000; // ë§ˆì§€ë§‰ í…ìŠ¤ì²˜(3000ms) ì´í›„ ì•½ê°„ì˜ ì—¬ìœ 

            if (__engineShutdownPlayed) return;
            __engineShutdownPlayed = true;

            // ì•ˆì „: ì…ë ¥/ì „íˆ¬ ì ê¹ ë¬¶ê¸°
            setBattle(false);
            sway.locked = true;

            // ë‹¨ê³„ë³„ í…ìŠ¤ì²˜ êµì²´ (ì†Œë“±: 2 â†’ 1 â†’ 0)
            scene.time.delayedCall(500, () => player.setTexture('playerShip_2'));
            scene.time.delayedCall(1000, () => player.setTexture('playerShip_1'));
            scene.time.delayedCall(1500, () => player.setTexture('playerShip_0'));

            // ğŸ”¸ ìƒì ì€ ì—”ì§„ ì†Œí™” ì—°ì¶œì´ ëë‚œ ë’¤ì— ì˜¤í”ˆ
            scene.time.delayedCall(openDelayMs, () => {
                // ì¤‘ë³µ ë°©ì§€: ì´ë¯¸ ìƒì  ì—´ë ¸ê±°ë‚˜ ì”¬ì´ íŒŒê´´ëœ ê²½ìš° ìŠ¤í‚µ
                if (!scene || !scene.scene || scene.scene.isPaused()) return;
                if (shop.active) return;
                openTempShop(scene);
            });
        }


        function setHitboxScaleX(mult) { //ver2
            // 1.0 ~ 3.0 ì •ë„ ë²”ìœ„ ì¶”ì²œ (ì›í•˜ë©´ ì¡°ì ˆ)
            weapon.hitboxScaleX = Phaser.Math.Clamp(Number(mult) || 1.0, 1.0, 3.0);
        }

        function openTempShop(scene) { //ver3
            if (shop.active) return;
            shop.active = true;

            if (missileHUDText) missileHUDText.setAlpha(0);

            const panelW = Math.floor(config.width * 0.9);
            const panelH = 320;
            const targetY = config.height / 2 + 10;

            // ë°˜íˆ¬ëª… ë°°ê²½ (ê³ ì •)
            shop.bg = scene.add.rectangle(
                config.width / 2, config.height / 2, config.width, config.height, 0x000000, 0.45
            ).setDepth(shop.depthBase);

            // ì»¨í…Œì´ë„ˆ (íŒ¨ë„+ìŠ¬ë¡¯+í•˜ë‹¨ë°” ì „ë¶€ ë‹´ìŒ)
            shop.container = scene.add.container(config.width / 2, -panelH).setDepth(shop.depthBase + 1);

            // í° ì‚¬ê°í˜• íŒ¨ë„ (ì»¨í…Œì´ë„ˆ ì¤‘ì‹¬ ê¸°ì¤€)
            const panel = scene.add.rectangle(0, 0, panelW, panelH, 0x111122, 0.95)
                .setStrokeStyle(2, 0x66ccff);
            shop.container.add(panel);

            // í‚¤ ë“±ë¡
            shop.keys = scene.input.keyboard.addKeys({
                '1': Phaser.Input.Keyboard.KeyCodes.ONE,
                '2': Phaser.Input.Keyboard.KeyCodes.TWO,
                '3': Phaser.Input.Keyboard.KeyCodes.THREE,
                '4': Phaser.Input.Keyboard.KeyCodes.FOUR,
                '5': Phaser.Input.Keyboard.KeyCodes.FIVE,
                '6': Phaser.Input.Keyboard.KeyCodes.SIX,
                '7': Phaser.Input.Keyboard.KeyCodes.SEVEN,
                '8': Phaser.Input.Keyboard.KeyCodes.EIGHT,
                'space': Phaser.Input.Keyboard.KeyCodes.SPACE,
            });

            // ìŠ¬ë¡¯ë“¤ (íŒ¨ë„ ë‚´ë¶€ì— ì™„ì „ ë°°ì¹˜)
            const cols = 4, rows = 2, pad = 16;
            const cellW = Math.floor((panelW - pad * (cols + 1)) / cols);
            const cellH = 88;

            const P = shop.purchasedOnce;
            const T = shop.tier;

            const labels = [
                // 1í–‰: 1 2 3 4
                {
                    key: '1', title: 'ê¸°ê´€í¬ 2ë°œ', price: 1,
                    canBuy: () => !P['1'],
                    onBuy: () => {
                        P['1'] = true; showUpgradeToast(scene, 'ê¸°ê´€í¬ 2ë°œ'); __refreshPurchasedCheck('1'); __refreshLockStates();
                        applyPatternByPurchases();
                    }

                },
                {
                    key: '2', title: 'ê¸°ê´€í¬ 3ë°œ', price: 1,
                    canBuy: () => P['1'] && !P['2'],                 // â† 1 ì„ í–‰
                    onBuy: () => {
                        P['2'] = true; showUpgradeToast(scene, 'ê¸°ê´€í¬ 3ë°œ'); __refreshPurchasedCheck('2'); __refreshLockStates();
                        applyPatternByPurchases();
                    }
                },
                {
                    key: '3', title: 'ë¯¸ì‚¬ì¼ í•´ê¸ˆ', price: 1,
                    canBuy: () => !P['3'],
                    onBuy: () => { P['3'] = true; showUpgradeToast(scene, 'ë¯¸ì‚¬ì¼ í•´ê¸ˆ'); __refreshPurchasedCheck('3'); __refreshLockStates(); }
                },
                {
                    key: '4', title: 'ë¯¸ì‚¬ì¼ 2ë°œ', price: 1,
                    canBuy: () => P['3'] && !P['4'],                 // â† 3 ì„ í–‰
                    onBuy: () => { P['4'] = true; showUpgradeToast(scene, 'ë¯¸ì‚¬ì¼ 2ë°œ'); __refreshPurchasedCheck('4'); __refreshLockStates(); }
                },

                // 2í–‰: 5 6 7 8
                {
                    key: '5', title: 'ì—°ì‚¬ë ¥ ê°•í™”\n', price: 1,
                    canBuy: () => T.a < 3,
                    onBuy: () => {
                        T.a++;
                        showUpgradeToast(scene, `ì—°ì‚¬ë ¥ ê°•í™” Lv.${T.a}`);
                        __refreshTierDesc('5');
                        applyROFByTier(scene);    // â˜… ì—°ì‚¬ ìˆ˜ì¹˜ ì¦‰ì‹œ ë°˜ì˜
                    }
                },
                {
                    key: '6', title: 'ë°ë¯¸ì§€ ê°•í™”\n', price: 1,
                    canBuy: () => T.s < 3,
                    onBuy: () => {
                        T.s++;
                        showUpgradeToast(scene, `ë°ë¯¸ì§€ ê°•í™” Lv.${T.s}`); __refreshTierDesc('6');
                        applyDamageByTier();
                        updateBulletSkinByDamageTier();
                    }
                },
                {
                    key: '7', title: 'ì²´ë ¥ ê°•í™”\n', price: 1,
                    canBuy: () => T.d < 3,
                    onBuy: () => { T.d++; showUpgradeToast(scene, `ì²´ë ¥ ê°•í™” Lv.${T.d}`); __refreshTierDesc('7'); }
                },
                {
                    key: '8', title: 'empty', price: 1,
                    canBuy: () => false,
                    onBuy: () => { }
                },
            ];

            shop.slots = [];
            for (let i = 0; i < labels.length; i++) {
                const c = i % cols;
                const r = (i / cols) | 0;

                // íŒ¨ë„ ë‚´ë¶€ ì¢Œìƒë‹¨ ê¸°ì¤€ (-panelW/2, -panelH/2)
                const left = -panelW / 2 + pad;
                const top = -panelH / 2 + pad;

                const x = Math.round(left + c * (cellW + pad) + cellW / 2);
                const y = Math.round(top + 20 + r * (cellH + pad)); // ìœ„ìª½ ì—¬ë°± 20

                const rect = scene.add.rectangle(x, y, cellW, cellH, 0x0f2033, 0.95)
                    .setStrokeStyle(1, 0x66ccff);
                const title = scene.add.text(x, y - 14, `${labels[i].key} | â‚²${labels[i].price ?? 1}`,
                    { fontSize: '13px', color: '#a8d2ff' }).setOrigin(0.5);
                const desc = scene.add.text(x, y + 10, labels[i].title,
                    { fontSize: '14px', color: '#cfe9ff', align: 'center' }).setOrigin(0.5);

                shop.container.add([rect, title, desc]);

                shop.slots.push({
                    key: labels[i].key.toLowerCase(),
                    rect, title, desc,
                    price: labels[i].price ?? 1,
                    canBuy: labels[i].canBuy ?? (() => true),
                    onBuy: labels[i].onBuy
                });
            }

            ['1', '2', '3', '4'].forEach(__refreshPurchasedCheck);
            ['5', '6', '7'].forEach(__refreshTierDesc);
            __refreshLockStates();

            // í•˜ë‹¨ ì „ì—­ ì§„í–‰ë°”/ë¼ë²¨/íŒíŠ¸ (íŒ¨ë„ ë°”ë‹¥ ê·¼ì²˜)
            const barW = panelW - 40;
            const barY = panelH / 2 - 28;
            shop.holdBarBg = scene.add.rectangle(0, barY, barW, 8, 0x0a1a2a, 1).setStrokeStyle(1, 0x66ccff);
            shop.holdBar = scene.add.rectangle(-barW / 2, barY, 0, 6, 0x66ccff, 1).setOrigin(0, 0.5);
            shop.holdLabel = scene.add.text(0, barY - 16, '', { fontSize: '13px', color: '#cfe9ff' }).setOrigin(0.5);
            shop.holdHint = scene.add.text(0, barY + 14,
                'Space : Take Off',
                { fontSize: '12px', color: '#9cc7ff' }).setOrigin(0.5);

            shop.container.add([shop.holdBarBg, shop.holdBar, shop.holdLabel, shop.holdHint]);

            // ì»¨í…Œì´ë„ˆ í†µì§¸ë¡œ ë‚´ë ¤ì˜¤ê¸°
            scene.tweens.add({
                targets: shop.container,
                y: targetY,
                duration: 700,
                ease: 'Cubic.easeOut'
            });
        }

        function updateTempShop(scene, deltaMs) { //ver2
            if (!shop.active) return;

            if (goldHUDText) goldHUDText.setText(`Gold: ${gold}`);

            // â˜… Space í™€ë“œ ìš°ì„  ì²˜ë¦¬
            const spaceObj = shop.keys && shop.keys['space'];
            if (spaceObj && spaceObj.isDown) {
                if (shop.holdingKey !== 'space') {
                    shop.holdingKey = 'space';
                    shop.holdingStart = scene.time.now;
                    if (shop.holdBar) shop.holdBar.width = 0;
                }

                const held = scene.time.now - (shop.holdingStart || scene.time.now);
                const p = Phaser.Math.Clamp(held / (shop.holdMsRequired || 2000), 0, 1);

                if (shop.holdBar && shop.holdBarBg) {
                    const full = shop.holdBarBg.width - 2;
                    shop.holdBar.width = Math.max(0, Math.floor(full * p));
                }
                if (shop.holdLabel) shop.holdLabel.setText(`ì´ë¥™ ì¤€ë¹„ì¤‘â€¦ ${Math.round(p * 100)}%`);

                if (p >= 1) {
                    // ì´ë¥™!
                    if (p >= 1) {
                        closeShopAndWait(scene);     // â† ì´ í•¨ìˆ˜ë¡œ êµì²´
                        shop.holdingKey = null;
                        shop.holdingStart = null;
                        if (shop.holdBar) shop.holdBar.width = 0;
                    }

                }
                return; // â˜… ìŠ¤í˜ì´ìŠ¤ ì²˜ë¦¬ ì¤‘ì—ëŠ” êµ¬ë§¤ ë¡œì§ ê±´ë„ˆëœ€
            }

            // â˜… ìŠ¤í˜ì´ìŠ¤ ì•ˆ ëˆ„ë¥´ëŠ” ë™ì•ˆì€ êµ¬ë§¤ ë¼ë²¨ ë¹„ì›€
            if (shop.holdLabel) shop.holdLabel.setText('');

            // ---- ì´í•˜ ê¸°ì¡´ êµ¬ë§¤(1~8) ë¡œì§ ìœ ì§€ ----
            const watchKeys = ['1', '2', '3', '4', '5', '6', '7', '8'];
            let pressedKey = null;
            for (const k of watchKeys) {
                const keyObj = shop.keys && shop.keys[k];
                if (keyObj && keyObj.isDown) { pressedKey = k; break; }
            }

            if (!pressedKey) {
                shop.holdingKey = null;
                shop.holdingStart = null;
                if (shop.holdBar) shop.holdBar.width = 0;
                return;
            }

            const slot = shop.slots.find(s => s.key === pressedKey);
            if (!slot) return;

            if (shop.holdingKey !== pressedKey) {
                shop.holdingKey = pressedKey;
                shop.holdingStart = scene.time.now;
                if (shop.holdBar) shop.holdBar.width = 0;
            }

            const held = scene.time.now - (shop.holdingStart || scene.time.now);
            const p = Phaser.Math.Clamp(held / (shop.holdMsRequired || 2000), 0, 1);

            if (shop.holdBar && shop.holdBarBg) {
                const full = shop.holdBarBg.width - 2;
                shop.holdBar.width = Math.max(0, Math.floor(full * p));
            }
            if (shop.holdLabel) shop.holdLabel.setText(`${pressedKey} êµ¬ë§¤ ì¤‘â€¦ ${Math.round(p * 100)}%`);

            if (p >= 1) {
                const price = (typeof slot.price === 'number') ? slot.price : 1;
                const canBuy = (typeof slot.canBuy === 'function') ? slot.canBuy() : true;

                if (!canBuy) {
                    shakeSlot(scene, slot);
                    if (shop.holdLabel) shop.holdLabel.setText('êµ¬ë§¤ ë¶ˆê°€');
                } else if (gold >= price) {
                    gold -= price;
                    try { if (typeof slot.onBuy === 'function') slot.onBuy(); } catch (e) { }
                    flashSlot(scene, slot);
                    if (shop.holdLabel) shop.holdLabel.setText('êµ¬ë§¤ ì™„ë£Œ!');
                } else {
                    shakeSlot(scene, slot);
                    if (shop.holdLabel) shop.holdLabel.setText('ê³¨ë“œ ë¶€ì¡±');
                }

                shop.holdingKey = null;
                shop.holdingStart = null;
                if (shop.holdBar) shop.holdBar.width = 0;
            }
        }


        // ì‹œê° í”¼ë“œë°±: êµ¬ë§¤ ì„±ê³µ ì‹œ ë°˜ì§
        function flashSlot(scene, slot) {//ver2
            scene.tweens.add({
                targets: [slot.rect],
                alpha: { from: 1, to: 0.4 },
                yoyo: true, repeat: 1,
                duration: 120
            });
        }

        // ì‹œê° í”¼ë“œë°±: ê³¨ë“œ ë¶€ì¡± ë“± ì‹¤íŒ¨ ì‹œ í”ë“¤ê¸°
        function shakeSlot(scene, slot) {//ver2
            scene.tweens.add({
                targets: [slot.rect, slot.title, slot.desc],
                x: `+=8`,
                yoyo: true, repeat: 3,
                duration: 40
            });
        }

        function showUpgradeToast(scene, label) {//ver2
            const msg = `${label} ì—…ê·¸ë ˆì´ë“œ ì„±ê³µ`;
            const t = scene.add.text(config.width / 2, Math.round(config.height * 0.28), msg, {
                fontSize: '20px', color: '#e6f5ff', fontStyle: 'bold', align: 'center',
                stroke: '#114466', strokeThickness: 2
            }).setOrigin(0.5).setDepth(shop.depthBase + 5);

            // ì‚´ì§ ë– ì˜¬ëë‹¤ê°€ ì‚¬ë¼ì§€ê¸°
            scene.tweens.add({
                targets: t,
                y: '-=18',
                alpha: { from: 1, to: 0 },
                duration: 800,
                ease: 'Cubic.easeOut',
                onComplete: () => t.destroy()
            });
        }

        function __findSlot(keyStr) { //ver2
            return shop.slots.find(s => s.key === keyStr);
        }

        function __getSlotByKey(k) { //ver2
            return shop.slots.find(s => s.key === k);
        }

        function __refreshPurchasedCheck(k) { //ver2
            const s = __getSlotByKey(k); if (!s) return;
            const bought = shop.purchasedOnce[k];
            const priceStr = bought ? 'âœ…' : `â‚²${s.price ?? 1}`;
            s.title.setText(`${k} | ${priceStr}`);
        }

        // 5~7: í‹°ì–´ ë¼ë²¨
        function __refreshTierDesc(k) { //ver2
            const s = __getSlotByKey(k); if (!s) return;

            // ì´ë¦„ ë§¤í•‘
            const name = { '5': 'ì—°ì‚¬ë ¥ ê°•í™”', '6': 'ë°ë¯¸ì§€ ê°•í™”', '7': 'ì²´ë ¥ ê°•í™”' }[k];

            // í˜„ì¬ í‹°ì–´ ì½ê¸° (tierëŠ” a/s/dë¡œ ìœ ì§€í•œ ë„ˆì˜ êµ¬ì¡° ê·¸ëŒ€ë¡œ ì‚¬ìš©)
            const lv = (k === '5') ? shop.tier.a
                : (k === '6') ? shop.tier.s
                    : (k === '7') ? shop.tier.d
                        : 0;

            const lvText = (lv >= 3) ? 'Lv MAX' : `Lv ${lv + 1}`;
            s.desc.setText(`${name}\n${lvText}`).setAlign('center');
        }

        // 2,4: ì„ í–‰ ë¯¸ì¶©ì¡± ì ê¸ˆ ìƒíƒœ ì‹œê°í™”
        function __refreshLockStates() { //ver2
            // 2ëŠ” 1 í•„ìš” / 4ëŠ” 3 í•„ìš”
            const need1 = !shop.purchasedOnce['1'];
            const need3 = !shop.purchasedOnce['3'];

            const lock2 = __getSlotByKey('2');
            if (lock2) {
                const locked = need1 && !shop.purchasedOnce['2'];
                __applyLockedStyle(lock2, locked, locked ? 'ì„ í–‰: 1ë²ˆ í•„ìš”' : '');
            }

            const lock4 = __getSlotByKey('4');
            if (lock4) {
                const locked = need3 && !shop.purchasedOnce['4'];
                __applyLockedStyle(lock4, locked, locked ? 'ì„ í–‰: 3ë²ˆ í•„ìš”' : '');
            }
        }

        // ì ê¸ˆ ìŠ¤íƒ€ì¼ ê³µí†µ ì²˜ë¦¬
        function __applyLockedStyle(slot, locked, hint) { //ver2
            const dim = locked ? 0.35 : 1;
            slot.rect.setAlpha(dim);
            slot.title.setAlpha(dim);
            slot.desc.setAlpha(dim);

            // ì ê¸ˆ íŒíŠ¸ ë¼ë²¨ ì¶”ê°€/ì—…ë°ì´íŠ¸
            if (!slot.lockHint) {
                slot.lockHint = slot.title.scene.add.text(slot.rect.x, slot.rect.y + slot.rect.height / 2 - 10, '',
                    { fontSize: '12px', color: '#ffb3b3' }).setOrigin(0.5);
                shop.container.add(slot.lockHint);
            }
            slot.lockHint.setText(locked ? hint : '');
            slot.lockHint.setAlpha(locked ? 1 : 0);
        }

        function closeShopAndWait(scene) { //ver2
            // íŒ¨ë„/ë°°ê²½ ì œê±°
            if (shop.container) {
                scene.tweens.add({
                    targets: shop.container,
                    y: shop.container.y - 80,
                    alpha: { from: 1, to: 0 },
                    duration: 300,
                    ease: 'Cubic.easeIn',
                    onComplete: () => {
                        shop.container.destroy();
                        shop.container = null;
                    }
                });
            }
            if (shop.bg) {
                scene.tweens.add({
                    targets: shop.bg,
                    alpha: { from: shop.bg.alpha, to: 0 },
                    duration: 250,
                    onComplete: () => { shop.bg.destroy(); shop.bg = null; }
                });
            }

            // ìƒíƒœ ì •ë¦¬: ìƒì  ë¹„í™œì„±í™”
            shop.active = false;
            shop.keys = null;
            shop.slots = [];

            // ì „íˆ¬/ì…ë ¥ì€ 'ëŒ€ê¸°' ìƒíƒœë¡œ ìœ ì§€
            setBattle(false);   // ì  ìŠ¤í°/ë°œì‚¬ ë©ˆì¶¤
            sway.active = false;
            sway.locked = true;

            playPreFlightCheck(scene, () => {
                startIgnitionUI(scene);
            });
        }

        function playPreFlightCheck(scene, onComplete) { //ver2
            // ë”¤ ë°°ê²½ (í…ìŠ¤íŠ¸ ë’¤, í™”ë©´ ì „ì²´)
            const dim = scene.add.rectangle(
                config.width / 2, config.height / 2, config.width, config.height,
                0x000000, 0.45
            ).setDepth(295);
            launch.dim = dim;

            const lines = [
                "[PRE-FLIGHT CHECK INITIATED]",
                "WEAPONS : ONLINE",
                "SHIELD  : ONLINE",
                "FUEL    : FULL",
                "AILERONS  : RESPONSIVE",
                "ELEVATORS : STABLE",
                "RUDDER    : CALIBRATED",
                "SYSTEM : ALL GREEN",
                "READY FOR TAKEOFF"
            ];

            const startY = config.height * 0.3;
            const lineSpacing = 28;

            const baseStyle = {
                fontSize: '20px',
                fontFamily: 'monospace',
                color: '#e8fdff'
            };

            // ğŸ‘‡ ì—¬ê¸°ì„œ ë§Œë“  í…ìŠ¤íŠ¸ë“¤ì„ launch.lines ë¡œ â€˜ê³µìœ â€™ (ë‚˜ì¤‘ì— ê·¸ëŒ€ë¡œ ì œê±°)
            launch.lines = [];
            const delayPer = 500;  // ì¤„ë‹¹ ë“±ì¥ ê°„ê²©
            const fadeDur = 400;

            lines.forEach((text, i) => {
                const t = scene.add.text(config.width / 2, startY + i * lineSpacing, text, baseStyle)
                    .setOrigin(0.5)
                    .setAlpha(0)
                    .setDepth(300)
                    .setStroke('#0b2a3a', 3)
                    .setShadow(0, 2, '#001a33', 8, true, true);

                launch.lines.push(t);

                scene.time.delayedCall(delayPer * i, () => {
                    scene.tweens.add({
                        targets: t,
                        alpha: { from: 0, to: 1 },
                        duration: fadeDur,
                        ease: 'Cubic.easeOut'
                    });

                    if (text === "SYSTEM : ALL GREEN") {
                        scene.tweens.add({
                            targets: t,
                            scale: { from: 1, to: 1.12 },
                            yoyo: true,
                            duration: 600,
                            ease: 'Sine.easeInOut'
                        });
                    }
                });
            });

            // ëª¨ë“  ì¤„ì´ ë“±ì¥í•œ â€˜ì§í›„â€™ ì œê±° ë‹¨ê³„ë¡œ ì§„ì…
            const totalShowTime = (lines.length - 1) * delayPer + fadeDur + 250; // ì—¬ìœ  0.25s
            scene.time.delayedCall(totalShowTime, () => {
                if (typeof onComplete === 'function') onComplete();
            });
        }


        function startIgnitionUI(scene) {  //ver2
            if (launch.active) return;
            launch.active = true;

            // ì´ë¯¸ playPreFlightCheck ì—ì„œ ë§Œë“  ì¤„ë“¤ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©
            launch.nextRemoveAt = scene.time.now + (launch.removeInterval || 300);

            // â€œEngine ignition Startâ€ ì¤€ë¹„(ì²˜ìŒì—” ìˆ¨ê¹€)
            const cx = config.width / 2;
            const baseY = Math.round(config.height * 0.58);
            launch.bigTitle = scene.add.text(cx, baseY - 10, 'Engine ignition Start', {
                fontSize: '32px',
                color: '#eaf6ff',
                fontStyle: 'bold',
                stroke: '#0b1a2a',
                strokeThickness: 4
            }).setOrigin(0.5).setDepth(300).setAlpha(0);
        }


        function updateLaunchUI(scene) { //ver2
            if (!launch.active) return;

            const now = scene.time.now;

            // 0.3ì´ˆë§ˆë‹¤ í•œ ì¤„ì”© ì œê±° (ìœ„ì—ì„œë¶€í„°)
            if (launch.lines.length > 0 && now >= launch.nextRemoveAt) {
                const t = launch.lines.shift();
                if (t) t.destroy();
                launch.nextRemoveAt = now + launch.removeInterval;

                // ëª¨ë‘ ì œê±° ì™„ë£Œ â†’ íƒ€ì´í‹€ í‘œì‹œ â†’ ìë™ ì í™”
                if (launch.lines.length === 0) {
                    scene.tweens.add({
                        targets: launch.bigTitle,
                        alpha: { from: 0, to: 1 },
                        y: '-=6',
                        duration: 220,
                        ease: 'Cubic.easeOut',
                        onComplete: () => {
                            scene.time.delayedCall(250, () => playEngineIgnition(scene));
                            launch.active = false; // UI í”Œë¡œìš° ì¢…ë£Œ
                        }
                    });
                }
            }
        }

        function playEngineIgnition(scene) { //ver2
            if (__engineIgnitionPlayed) return;
            __engineIgnitionPlayed = true;

            // í”Œë ˆì´ì–´ í…ìŠ¤ì²˜ ìë™ ì‹œí€€ìŠ¤: 0 -> 1 -> 2
            player.setTexture('playerShip_0');
            scene.time.delayedCall(200, () => player.setTexture('playerShip_1'));
            scene.time.delayedCall(800, () => player.setTexture('playerShip_2'));

            // (ì„ íƒ) ì´í™íŠ¸ í† ìŠ¤íŠ¸
            const ignite = scene.add.text(config.width / 2, Math.round(config.height * 0.35), 'IGNITION!', {
                fontSize: '28px',
                color: '#eaf6ff',
                fontStyle: 'bold',
                stroke: '#0b1a2a',
                strokeThickness: 4
            }).setOrigin(0.5).setDepth(320).setAlpha(0);

            scene.tweens.add({
                targets: ignite,
                alpha: { from: 0, to: 1 },
                y: '-=10',
                duration: 250,
                yoyo: true,
                repeat: 1,
                onComplete: () => ignite.destroy()
            });

            scene.time.delayedCall(900, () => {
                if (launch.bigTitle) {
                    scene.tweens.add({
                        targets: launch.bigTitle,
                        alpha: 0,
                        y: '+=8',
                        duration: 300,
                        ease: 'Cubic.easeIn',
                        onComplete: () => {
                            launch.bigTitle.destroy();
                            launch.bigTitle = null;
                            showTakeOff(scene); // â† ë‹¤ìŒ ë‹¨ê³„
                        }
                    });
                } else {
                    showTakeOff(scene);
                }
            });
        }

        function showTakeOff(scene) {// ver2
            const cx = config.width / 2;
            const y = Math.round(config.height * 0.56);

            // TAKE OFF! í…ìŠ¤íŠ¸
            const takeoff = scene.add.text(cx, y, 'TAKE OFF!', {
                fontSize: '40px',
                fontStyle: 'bold',
                color: '#eaf6ff',
                stroke: '#0b1a2a',
                strokeThickness: 5
            }).setOrigin(0.5).setDepth(330).setAlpha(0);

            scene.tweens.add({
                targets: takeoff,
                alpha: { from: 0, to: 1 },
                y: '-=10',
                duration: 280,
                ease: 'Cubic.easeOut',
                yoyo: true,
                repeat: 1,
                onComplete: () => {
                    // ì ê¹ ë³´ì—¬ì¤€ ë’¤ ìì—°ìŠ¤ëŸ½ê²Œ ì‚¬ë¼ì§€ê²Œ í•˜ê³  ì‹¶ë‹¤ë©´:
                    scene.tweens.add({
                        targets: takeoff,
                        alpha: 0,
                        duration: 350,
                        delay: 200,
                        onComplete: () => takeoff.destroy()
                    });
                }
            });

            // í•­ëª¨ë¥¼ ì•„ë˜ë¡œ í‡´ì¥
            if (docking.carrier) {
                scene.tweens.add({
                    targets: docking.carrier,
                    y: config.height + docking.carrier.displayHeight,
                    duration: 1500,
                    ease: 'Cubic.easeIn',
                    onComplete: () => {
                        docking.carrier.destroy();
                        docking.carrier = null;
                    }
                });
            }

            // í”„ë¦¬í”Œë¼ì´íŠ¸ ë”¤ ë°°ê²½ í˜ì´ë“œì•„ì›ƒ
            if (launch.dim) {
                scene.tweens.add({
                    targets: launch.dim,
                    alpha: 0,
                    duration: 400,
                    onComplete: () => {
                        launch.dim.destroy();
                        launch.dim = null;
                    }
                });
            }

            // (ì„ íƒ) ì´ì œë¶€í„° ì „íˆ¬ ì¬ê°œí•˜ê±°ë‚˜, í”Œë ˆì´ì–´ ì œì–´ í’€ê¸° ë“±:
            sway.locked = false;
            setBattle(true);
        }

        function updateBulletSkinByDamageTier() { //ver3
            // shop.tier.s : ë°ë¯¸ì§€ ê°•í™” ë‹¨ê³„(0~3)
            const s = (shop && shop.tier && typeof shop.tier.s === 'number') ? shop.tier.s : 0;
            const idx = Phaser.Math.Clamp(s, 0, 3);
            weapon.bulletKey = BULLET_SKINS[idx];
        }

        function applyROFByTier(scene) { //ver3
            const a = Phaser.Math.Clamp(((shop && shop.tier && shop.tier.a) || 0), 0, 3);
            const prev = weapon.fireRateMs;
            const next = __FIRERATE_TABLE[a];

            weapon.fireRateMs = next;

            // ì—…ê¸€ ì§í›„ ì²«ë°œ íƒ€ì´ë° ìì—°ìŠ¤ëŸ½ê²Œ: ë” ë¹¨ë¼ì¡Œë‹¤ë©´ ëŒ€ê¸°ì‹œê°„ ë³´ì •
            if (scene && scene.time && next < prev) {
                lastFired = scene.time.now - next + 1; // ë°”ë¡œ(ë˜ëŠ” ê±°ì˜ ë°”ë¡œ) ë‚˜ê°€ê²Œ
            }
        }

        function applyPatternByPurchases() { //ver3
            // ê¸°ë³¸ 1ë°œ
            weapon.pattern = 1;
            if (shop?.purchasedOnce?.['1']) weapon.pattern = 2; // 1ë²ˆ êµ¬ë§¤ â†’ 2ë°œ
            if (shop?.purchasedOnce?.['2']) weapon.pattern = 3; // 2ë²ˆê¹Œì§€ êµ¬ë§¤ â†’ 3ë°œ
        }

        function applyDamageByTier() { //ver3
            const s = (shop && shop.tier && typeof shop.tier.s === 'number') ? shop.tier.s : 0;
            weapon.damage = __DAMAGE_TABLE[Math.max(0, Math.min(3, s))];
        }

        function applyMissileDamageByTier() { //ver3
            const s = (shop && shop.tier && typeof shop.tier.s === 'number') ? shop.tier.s : 0;
            const idx = Phaser.Math.Clamp(s, 0, 3);
            missile.explosionDamage = __MISSILE_DAMAGE_TABLE[idx];
        }

        function preload() { //ver3
            this.load.image('playerShip', 'assets/player/player1.png');
            this.load.image('playerShip_2', 'assets/player/player1_2.png'); // ì í™” ê°•
            this.load.image('playerShip_1', 'assets/player/player1_1.png'); // ì í™” ì•½
            this.load.image('playerShip_0', 'assets/player/player1_0.png'); // ì†Œë“±

            this.load.image('bulletB1', 'assets/bullets/bulletB1.png');
            this.load.image('bulletR1', 'assets/bullets/bulletR1.png');
            this.load.image('bulletG1', 'assets/bullets/bulletG1.png');
            this.load.image('bulletW1', 'assets/bullets/bulletW1.png');

            this.load.image('playerMissile', 'assets/missile/playerMissile.png');
            this.load.image('missileEx', 'assets/missile/missileEx.png');

            this.load.image('carrier', 'assets/player/carrier1.png'); // ê²½ë¡œì— ë§ê²Œ ìˆ˜ì •
        }

        function startMissileSequence(scene) { //ver3
            primaryHold.active = true;                    // ê¸°ê´€í¬ ì¼ì‹œ ì •ì§€
            const now = scene.time.now;

            // preHold í›„ ë°œì‚¬
            scene.time.delayedCall(missile.preHoldMs, () => {
                fireMissiles(scene);                        // ë°œì‚¬
                missile.lastFiredAt = now;                  // ì¿¨íƒ€ì„ ì‹œì‘

                // postHold í›„ ê¸°ê´€í¬ ì¬ê°œ
                scene.time.delayedCall(missile.postHoldMs, () => {
                    primaryHold.active = false;
                });
            });
        }

        function fireMissiles(scene) { //ver3
            const twoShot = !!shop?.purchasedOnce?.['4'];
            const cx = player.x, cy = player.y - 28;

            if (!twoShot) {
                shootOne(scene, cx, cy);
            } else {
                const off = 12; // ì¢Œìš° ê°„ê²© (14~18ë„ ì¶”ì²œ)
                const firstSide = missile.nextSide;   // 1 ë˜ëŠ” -1
                const secondSide = -missile.nextSide;
                missile.nextSide = -missile.nextSide; // ë‹¤ìŒì—” ë°˜ëŒ€ìª½ë¶€í„° ì‹œì‘

                // 1ë°œì°¨: ì¦‰ì‹œ
                shootOne(scene, cx + (firstSide * off), cy);

                // 2ë°œì°¨: ì‹œê°„ì°¨
                scene.time.delayedCall(missile.staggerMs, () => {
                    shootOne(scene, cx + (secondSide * off), cy);
                });
            }

            function shootOne(scene, x, y) {
                const m = missiles.get(x, y);
                if (!m) return;

                m.setActive(true).setVisible(true);
                m.body.enable = true;
                m.setTexture('playerMissile');

                // ë³´ê¸° í¬ê¸° (í•„ìš”ì‹œ ì¡°ì •)
                const tex = scene.textures.get('playerMissile').getSourceImage();
                const targetH = 28; // 24~32 ì¶”ì²œ
                const mScale = targetH / tex.height;
                m.setScale(mScale);

                // ìŠ¬ë¦¼í•œ íˆíŠ¸ë°•ìŠ¤
                if (m.body) m.body.setSize(m.displayWidth * 0.7, m.displayHeight, true);

                m.setVelocity(0, -missile.speed);
                m.setAngle(0);
                m.setDepth(50);

                // í™”ë©´ ìƒë‹¨ ë°–ì—ì„œ í„°ì§€ëŠ” ê²ƒ ë°©ì§€: ë²—ì–´ë‚˜ë©´ ì¦‰ì‹œ í­ë°œ
                scene.time.delayedCall(30, () => {
                    if (m.active && m.y < -8) {
                        spawnExplosion(scene, m.x, m.y);
                        m.setActive(false).setVisible(false);
                        m.body.enable = false;
                    }
                });

                // ìµœëŒ€ ë¹„í–‰ ì‹œê°„ í›„ ìë™ í­ë°œ
                scene.time.delayedCall(missile.maxFlightMs, () => {
                    if (!m.active) return;
                    spawnExplosion(scene, m.x, m.y);
                    m.setActive(false).setVisible(false);
                    m.body.enable = false;
                });
            }
        }

        function spawnExplosion(scene, x, y) { // ver3
            const ex = explosions.get(x, y);
            if (!ex) return;

            ex.setActive(true).setVisible(true);
            ex.setTexture('missileEx');
            ex.setDepth(999);

            // ë°˜ê²½ ìŠ¤ì¼€ì¼ (ì‹œê°ìš©)
            const radius = missile.explosionRadius;
            const baseW = scene.textures.get('missileEx').getSourceImage().width;
            const scale = (radius * 2) / baseW;
            ex.setScale(scale);

            //  íˆíŠ¸ë°•ìŠ¤

            if (ex.body && ex.body.setCircle) {
                const hitboxR = radius * 1.5; // ì‹œê°ë³´ë‹¤ 1.5ë°° í° ì¶©ëŒ ë²”ìœ„
                const offsetX = ex.displayWidth / 2 - hitboxR;
                const offsetY = ex.displayHeight / 2 - hitboxR;

                ex.body.setCircle(hitboxR, offsetX, offsetY);
                ex.body.immovable = true;
                ex.body.allowGravity = false;
                ex.body.moves = false;
            }

            // í­ë°œ ìˆœê°„ 1íšŒë§Œ íŒì • (ìŠ¤ëƒ…ìƒ·)
            scene.physics.overlap(ex, enemies, (eX, enemy) => {
                // ì²´ë ¥ ì‹œìŠ¤í…œ ë¶™ìœ¼ë©´: enemy.hp -= missile.explosionDamage;
                enemy.setActive(false).setVisible(false);
                enemy.body.enable = false;
            });

            // ì§§ê²Œ í˜ì´ë“œì•„ì›ƒ í›„ ì¬ì‚¬ìš©
            scene.tweens.add({
                targets: ex,
                alpha: { from: 1, to: 0 },
                duration: missile.explosionLifeMs,
                onComplete: () => {
                    ex.setActive(false).setVisible(false);
                    ex.body.enable = false;
                    ex.alpha = 1;
                }
            });
        }



        //-----------------ì—¬ê¸°ê¹Œì§€---------------------


        function create() {

            this.bKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.B); // í…ŒìŠ¤íŠ¸ ì¹˜íŠ¸í‚¤
            this.eKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E); // ë¯¸ì‚¬ì¼ ë°œì‚¬ ver3


            // ë°°ê²½ìƒ‰ ì„¤ì • (CSSì˜ background-colorì™€ ìº”ë²„ìŠ¤ ë‚´ë¶€ì˜ ë°°ê²½ìƒ‰)
            this.cameras.main.setBackgroundColor('#000033'); // ì§„í•œ íŒŒë€ìƒ‰ ë°°ê²½

            scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '24px', fill: '#fff' });

            // ì ìˆ˜ í…ìŠ¤íŠ¸ ì•„ë˜ì— ê³¨ë“œ HUD
            scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '24px', fill: '#fff' });
            goldHUDText = this.add.text(16, 40, `Gold: ${gold}`, { fontSize: '18px', fill: '#cfe9ff' });

            // í”Œë ˆì´ì–´ (ì‚¬ê°í˜•) ìƒì„±
            player = this.physics.add.image(config.width / 2, config.height - 50, 'playerShip')
                .setOrigin(0.5, 0.5)
                .setScale(0.07);
            player.setDepth(40);

            player.setCollideWorldBounds(true); // í™”ë©´ ë°–ìœ¼ë¡œ ëª» ë‚˜ê°€ê²Œ

            //----------------ìˆ˜ì •3--------------------------

            updateBulletSkinByDamageTier(); //ver3

            //createBulletTextures(this); //ver3 (í•„ìš” ì—†ì–´ì ¸ì„œ ì‚­ì œ)

            bullets = this.physics.add.group({ //ver3
                defaultKey: 'bulletB1',
                maxSize: 120
            });

            applyROFByTier(this); //ver3
            applyPatternByPurchases(); //ver3
            applyDamageByTier(); //ver3
            applyMissileDamageByTier(); //ver3

            bullets.createMultiple({ //ver2
                key: 'bulletB1',
                active: false,
                visible: false,
                repeat: 60,
                setXY: { x: -100, y: -100 }
            });

            bullets.children.entries.forEach(bullet => { //ver2
                bullet.body.setSize(10, 20); // ì¶©ëŒ ë°•ìŠ¤ í¬ê¸°
            });

            function createBulletTextures(scene) { //ver2
                if (scene.textures.exists('bullet_blue')) return;

                const make = (key, w, h, color) => {
                    const g = scene.add.graphics();
                    g.fillStyle(color, 1);
                    g.fillRoundedRect(0, 0, w, h, Math.min(w, h) * 0.45);
                    g.fillStyle(0xffffff, 0.35);
                    g.fillRoundedRect(w * 0.2, h * 0.15, w * 0.6, h * 0.3, Math.min(w, h) * 0.3);
                    g.generateTexture(key, w, h);
                    g.destroy();
                };

                make('bullet_blue', 8, 18, 0x4cc3ff);
                make('bullet_blue_bold', 10, 22, 0x66aaff);
            }

            if (!this.textures.exists('enemy')) { //ver2
                const g = this.add.graphics();
                g.fillStyle(0x992222, 1);
                g.fillCircle(10, 10, 10);
                g.lineStyle(2, 0xff4444, 1);
                g.strokeCircle(10, 10, 10);
                g.generateTexture('enemy', 20, 20);
                g.destroy();
            }

            missiles = this.physics.add.group({ defaultKey: 'playerMissile', maxSize: 48 });  // ver3
            explosions = this.physics.add.group({ defaultKey: 'missileEx', maxSize: 24 });    // ver3

            missileHUDText = this.add.text( //ver3
                Math.floor(config.width / 2),
                config.height - 18,
                '',
                { fontSize: '14px', color: '#cfe9ff', align: 'center' }
            ).setOrigin(0.5).setDepth(500);

            // ì²˜ìŒì—” ì „íˆ¬/í•´ê¸ˆ ìƒíƒœì— ë§ì¶° í‘œì‹œ
            if (!battleOn || !shop?.purchasedOnce?.['3']) {
                missileHUDText.setAlpha(0);
            } else {
                missileHUDText.setAlpha(1);
            }

            //-----------------ì—¬ê¸°ê¹Œì§€3--------------------

            // ì  ê·¸ë£¹ ìƒì„±
            enemies = this.physics.add.group();

            // ì  ìƒì„± ì´ë²¤íŠ¸ (2ì´ˆë§ˆë‹¤)
            enemySpawnEvent = this.time.addEvent({
                delay: 2000,
                callback: spawnEnemy,
                callbackScope: this,
                loop: true
            });

            // ì ìˆ˜ í…ìŠ¤íŠ¸
            scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '24px', fill: '#fff' });

            // ë§ˆìš°ìŠ¤/í„°ì¹˜ ì…ë ¥ ì„¤ì • // ìˆ˜ì •o
            this.input.on('pointermove', (pointer) => {
                if (gameOver) return;
                if (!sway.locked) {
                    sway.playerBaseX = Phaser.Math.Clamp(pointer.x, 20, config.width - 20);
                    if (!sway.active) {
                        // ğŸ”§ í”ë“¤ë¦¼ ë¹„í™œì„± ìƒíƒœì—ì„œëŠ” ë°”ë¡œ ë”°ë¼ê°€ê²Œ
                        player.x = sway.playerBaseX;
                    }
                }
            });

            // ì¶©ëŒ ì²˜ë¦¬: ì´ì•Œê³¼ ì 
            this.physics.add.overlap(bullets, enemies, hitEnemy, null, this);
            // ì¶©ëŒ ì²˜ë¦¬: í”Œë ˆì´ì–´ì™€ ì  (ê²Œì„ ì˜¤ë²„)
            this.physics.add.overlap(player, enemies, hitPlayer, null, this);

            // ì¶©ëŒ ì²˜ë¦¬: ë¯¸ì‚¬ì¼ê³¼ ì 
            this.physics.add.overlap(missiles, enemies, (m, enemy) => { // ver3
                spawnExplosion(this, m.x, m.y);
                m.setActive(false).setVisible(false);
                m.body.enable = false;

                // ì²´ë ¥ ì‹œìŠ¤í…œ ì „: í”¼ë“œë°± ê²¸ ì œê±°
                enemy.setActive(false).setVisible(false); //ver3
                enemy.body.enable = false;
            }, null, this);

            applyPatternByPurchases(); //ver3

            sway.playerBaseX = config.width / 2; //ì—¬ê¸°ë„ ìˆ˜ì •o
            player.x = sway.playerBaseX; //
        }

        function update(time) {
            if (gameOver) return;

            //--------------------------------ìˆ˜ì •ë¶€---------------------

            if (missileHUDText) {
                const unlocked = !!(shop?.purchasedOnce?.['3']);
                const activeBattle = battleOn && !shop.active;

                if (!activeBattle || !unlocked) {
                    // ì „íˆ¬OFF/ìƒì ì—´ë¦¼/ë¯¸í•´ê¸ˆ â†’ ìˆ¨ê¹€
                    missileHUDText.setAlpha(0).setText('');
                } else {
                    missileHUDText.setAlpha(1);
                    const now = this.time.now;
                    const remainMs = Math.max(0, missile.cooldownMs - (now - missile.lastFiredAt));

                    if (primaryHold.active) {
                        missileHUDText.setText('ë¯¸ì‚¬ì¼ ë°œì‚¬ ì¤‘â€¦');
                    } else if (remainMs > 0) {
                        const remainSec = (remainMs / 1000).toFixed(1);
                        missileHUDText.setText(`ë¯¸ì‚¬ì¼ ëƒ‰ê°ì¤‘: ${remainSec}s`);
                    } else {
                        missileHUDText.setText('ë¯¸ì‚¬ì¼ ì¤€ë¹„ë¨');
                    }
                }
            }

            if (docking.active) {
                updateCarrierDocking(this, this.game.loop.delta);
            }

            // ğŸ”¹ Bí‚¤: battle OFF (ì  ìŠ¤í° + ìƒˆ íƒ„ ë°œì‚¬ ì •ì§€)
            if (Phaser.Input.Keyboard.JustDown(this.bKey)) {
                startCarrierApproach(this);
            }

            if (!shop.active && battleOn && shop?.purchasedOnce?.['3']) { //ver3
                if (Phaser.Input.Keyboard.JustDown(this.eKey)) {
                    const now = this.time.now;
                    const ready = (now - missile.lastFiredAt) >= missile.cooldownMs;
                    if (ready && !primaryHold.active) {
                        startMissileSequence(this); // ê¸°ê´€í¬ ì¼ì‹œì •ì§€ â†’ ë¯¸ì‚¬ì¼ ë°œì‚¬ â†’ ì¬ê°œ
                    }
                }
            }

            // ===== í”ë“¤ë¦¼ ì ìš©(í”Œë ˆì´ì–´) & ì ‘ì´‰ ê°ì§€ =====
            if (sway.active) {
                if (!sway.locked) {
                    const dt = this.game.loop.delta / 1000;
                    sway.playerPhase += dt * (2 * Math.PI * sway.playerHz);
                    const offset = Math.sin(sway.playerPhase) * sway.playerAmp;

                    const targetX = Phaser.Math.Clamp((sway.playerBaseX ?? player.x) + offset, 20, config.width - 20);
                    player.x = targetX;
                }

                if (docking.active && docking.carrier && !sway.locked) {
                    const playerTopY = player.y - player.displayHeight / 2;

                    // ğŸ‘‡ â€˜ì‹¤ì œ ë½ ë¼ì¸â€™: í•­ëª¨ì˜ ë³´ì´ëŠ” ë°”ë‹¥(y)ì—ì„œ lockOffsetPx ë§Œí¼ ìœ„
                    const lockLineY = docking.carrier.y - docking.lockOffsetPx;

                    if (playerTopY <= lockLineY) {
                        lockToCenter(this);
                    }
                }

            } else {
                // ğŸ”§ í”ë“¤ë¦¼ ë¹„í™œì„± ìƒíƒœ: ë§ˆìš°ìŠ¤ ê¸°ì¤€ê°’ìœ¼ë¡œ ë°”ë¡œ ìœ„ì¹˜ ë°˜ì˜
                if (!sway.locked && sway.playerBaseX != null) {
                    player.x = sway.playerBaseX;
                }
            }

            fireFromPlayer(this, time); //ver2

            function updateCarrierDocking(scene, deltaMs) {
                if (!docking.active || !docking.carrier) return;

                const left = docking.guideLeftX - docking.tolerance;
                const right = docking.guideRightX + docking.tolerance;
                const aligned = (player.x >= left && player.x <= right);

                drawGuides(scene, aligned);

                if (aligned) {
                    // ì •ë ¬ ìƒíƒœ: í•­ëª¨ê°€ í•˜ê°•
                    const dy = (docking.descentPxPerSec * deltaMs) / 1000;
                    docking.carrier.y = Math.min(docking.carrier.y + dy, docking.targetY);
                } else {
                    // ì •ë ¬ì—ì„œ ë²—ì–´ë‚˜ë©´ ì²œì²œíˆ ìœ„ë¡œ ìƒìŠ¹
                    const uy = (docking.ascentPxPerSec * deltaMs) / 1000;
                    // ë„í‚¹ ì‹œì‘ ì‹œì ë³´ë‹¤ ë” ìœ„ë¡œëŠ” ëª» ì˜¬ë¼ê°€ê²Œ
                    docking.carrier.y = Math.max(docking.minY, docking.carrier.y - uy);
                }

                // ì°©í•¨ ì™„ë£Œ íŒì •
                if (docking.carrier.y >= docking.targetY - 0.5) {
                    docking.active = false;
                    if (docking.guide) {
                        docking.guide.destroy();
                        docking.guide = null;
                    }

                    carrierEventOn = false;

                    // âœ… ì—”ì§„ ì†Œë“± ì—°ì¶œ
                    playEngineShutdown(scene);
                }
            }

            function fireFromPlayer(scene, time) { //ver3
                if (!battleOn) return;
                if (primaryHold.active) return;
                if (time <= lastFired + (weapon.fireRateMs ?? 200)) return;

                const cx = player.x;
                const cy = player.y - 20;

                let lane;
                if (weapon.pattern === 2) {
                    lane = Math.max(6, Math.floor(player.displayWidth * 0.14));  // â† ê°„ê²© ì¢í˜
                } else {
                    lane = Math.max(8, Math.floor(player.displayWidth * 0.28));  // â† ê¸°ì¡´ê°’
                }

                // â”€â”€ íŒ¨í„´ë³„ "ìˆ˜ì§ í‰í–‰ë°œ" ì¢Œí‘œ â”€â”€
                const shots = [];
                if (weapon.pattern === 1) {
                    shots.push({ x: cx, y: cy });
                } else if (weapon.pattern === 2) {
                    shots.push({ x: cx - lane, y: cy });
                    shots.push({ x: cx + lane, y: cy });
                } else if (weapon.pattern === 3) {
                    shots.push({ x: cx - lane, y: cy });
                    shots.push({ x: cx, y: cy });
                    shots.push({ x: cx + lane, y: cy });
                }

                // ìƒì„± & ìˆ˜ì§ ë°œì‚¬
                for (const s of shots) {
                    const b = bullets.get(s.x, s.y);
                    if (!b) continue;

                    b.setActive(true).setVisible(true);
                    b.body.enable = true;

                    b.setTexture(weapon.bulletKey || 'bulletB1');

                    // ìŠ¤í”„ë¼ì´íŠ¸ ìŠ¤ì¼€ì¼(ì›í•˜ëŠ” ë†’ì´ë¡œ í†µì¼)
                    const tex = scene.textures.get(b.texture.key).getSourceImage();
                    const targetH = 18;
                    const scale = targetH / tex.height;
                    b.setScale(scale);

                    // íˆíŠ¸ë°•ìŠ¤(ê°€ë¡œ ë°°ìˆ˜ ì˜µì…˜ ë°˜ì˜)
                    const bodyW = b.displayWidth * (weapon.hitboxScaleX ?? 1.0);
                    const bodyH = b.displayHeight;
                    b.body.setSize(bodyW, bodyH, true);

                    // ëª¨ë‘ ìˆ˜ì§(-90Â°)ë¡œ í‰í–‰ ë°œì‚¬
                    b.setVelocity(0, -(weapon.bulletSpeed ?? 400));
                    b.setAngle(0); // ìŠ¤í”„ë¼ì´íŠ¸ê°€ ìœ„ë¡œ ë³´ì´ë„ë¡(í•„ìš”ì‹œ -90/90ì€ ì—ì…‹ ê¸°ì¤€ì— ë§ì¶° ì¡°ì •)
                }

                lastFired = time;
            }


            updateTempShop(this, this.game.loop.delta); //ver2

            updateLaunchUI(this); //ver2

            //-------------------------ì—¬ê¸°ê¹Œì§€-----------------------

            // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°„ ì´ì•Œ ë¹„í™œì„±í™”
            bullets.children.each(function (b) {
                if (b.active && b.y < 0) {
                    b.setActive(false).setVisible(false);
                    b.body.enable = false; // ë¬¼ë¦¬ ë¹„í™œì„±í™”
                }
            });

            // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°„ ì  ë¹„í™œì„±í™” (ì•„ë˜ë¡œ ë‚˜ê°)
            enemies.children.each(function (enemy) {
                if (enemy.active && enemy.y > config.height + 50) {
                    enemy.setActive(false).setVisible(false);
                    enemy.body.enable = false;
                }
            });
        }

        function hitEnemy(bullet, enemy) {
            // ì´ì•Œê³¼ ì ì´ ë¶€ë”ªíˆë©´ ë‘˜ ë‹¤ ë¹„í™œì„±í™”
            bullet.setActive(false).setVisible(false);
            bullet.body.enable = false;

            enemy.setActive(false).setVisible(false);
            enemy.body.enable = false;

            score += 10;
            scoreText.setText('Score: ' + score);
        }

        function hitPlayer(player, enemy) {
            if (gameOver) return;

            // í”Œë ˆì´ì–´ê°€ ì ì—ê²Œ ë§ìœ¼ë©´ ê²Œì„ ì˜¤ë²„
            this.physics.pause();
            player.setTint(0xff0000); // í”Œë ˆì´ì–´ë¥¼ ë¹¨ê°›ê²Œ
            gameOver = true;

            this.add.text(config.width / 2, config.height / 2, 'GAME OVER', { fontSize: '48px', fill: '#fff' }).setOrigin(0.5);
            this.add.text(config.width / 2, config.height / 2 + 60, 'Restart F5', { fontSize: '24px', fill: '#fff' }).setOrigin(0.5);
        }

        // PhaserëŠ” ì´ë¯¸ì§€ë¥¼ ë¡œë“œí•˜ì§€ ì•Šìœ¼ë©´ ê°ì²´ë¥¼ ë§Œë“¤ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ,
        // ë”ë¯¸ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•˜ëŠ” í—¬í¼ í•¨ìˆ˜ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤. (create í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ê¸° ì „ì—)
        Phaser.GameObjects.GameObjectFactory.register('image', function (x, y, key, frame) {
            if (!this.scene.textures.exists(key)) {
                // í•´ë‹¹ í‚¤ì˜ í…ìŠ¤ì²˜ê°€ ì—†ìœ¼ë©´ ë¹ˆ í…ìŠ¤ì²˜ë¥¼ ë§Œë“­ë‹ˆë‹¤.
                let graphics = this.scene.add.graphics({ fillStyle: { color: 0xffffff } });
                graphics.fillRect(0, 0, 32, 32); // 32x32 í°ìƒ‰ ì‚¬ê°í˜•
                graphics.generateTexture(key, 32, 32);
                graphics.destroy();
            }
            return this.displayList.add(new Phaser.GameObjects.Image(this.scene, x, y, key, frame));
        });


    </script>

</body>

</html>